https://leetcode.com/problems/find-edges-in-shortest-paths/description/



// Dijkstra + backtracking

class Solution {
public:
    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {
        int totalEdges = edges.size();
        vector<bool> ans(totalEdges, false);
        using pii = pair<int, pair<int, int>>;
        using piii = pair<int, pair<int, pair<int,int>>>;
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        vector<vector<pii>> adj(n);
        vector<int> dist(n, INT_MAX);
        vector<vector<pair<int,int>>> parent(n);
        vector<vector<pair<int,int>>> paths;
        vector<pair<int,int>> p;
        
        for(int i = 0 ; i < totalEdges ; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            int wt = edges[i][2];
            adj[u].push_back({i, {v, wt}});
            adj[v].push_back({i, {u, wt}});
        }
        
        pq.push({0, {0, -1}});
        dist[0] = 0;
        parent[0] = {{-1, -1}};
        
        while(!pq.empty()) {
            int w = pq.top().first;
            int node = pq.top().second.first;
            int idx = pq.top().second.second;
            pq.pop();
            
            for(auto& p : adj[node]) {
                int child = p.second.first;
                int cwt = p.second.second;
                int cidx = p.first;
                
                if(dist[child] > w + cwt) {
                    dist[child] = w + cwt;
                    pq.push({dist[child], {child, cidx}});
                    parent[child] = {{node, cidx}};
                } 
                else if(dist[child] == w + cwt) {
                    parent[child].push_back({node, cidx});
                }
            }
        }
        
        auto findP = [&] (auto& findP, vector<pair<int,int>> &p, int currNode) -> void {
            if(currNode == -1) {
                paths.push_back(p);
                return;
            }
            for (auto &[parentOfCurrNode, edgeIndex] : parent[currNode]) {
                p.push_back({currNode, edgeIndex});

                findP(findP, p, parentOfCurrNode);

                p.pop_back();
            }
        };
        
        findP(findP, p, n-1);
        
        for(vector<pair<int,int>> &v : paths) {
            for(auto &[node, edgeIndex] : v) {
                // cout << node << ":" << edgeIndex << ",";
                if(edgeIndex != -1) ans[edgeIndex] = true;
            }
            // cout << endl;
        }
        
        return ans;
    }
};
